# C

# lessons 6 
# Константные объекты классов и константные методы классов
Объекты классов можно сделать константными (используя ключевое слово const). Инициализация
таких объектов выполняется посредством конструкторов. После инициализации такого объекта
любая попытка изменить члены-данные (поля) объекта запрещена, так как это нарушает
принципы константности объекта. Запрещается как изменение членов-данных напрямую, если
они являются открытыми (public), так и вызов методов (сеттеров) с помощью которых можно
установить значения членам-данным. Определяются константные объекты с помощью
следующего синтаксиса:

```C++
const <имя класса>[(<фактические параметры конструктора>)]
```
Например:
```C++
class Point{
private:
  int _x;
  int _y;
public:
  Point(int x = 0, int y = 0) : _x(x), _y(y)
  {
  }
  void set_x(const int& value) { _x = x; }
  int get_x() { return _x; }

  ...

};

int main(){
  const Point p1(1, 2); // дальше уже данный объект никак изменить не получиться ( т.к он константный )
  ...
}
```
Если продолжить предыдущий пример и попытаться вызвать метод-геттер, то к удивлению
получим ошибку.. ( забыли про const )
Константный метод — это метод, который гарантированно не изменяет объект и не вызывает неконстантные методы класса
```C++
class Point{
private:
  int _x;
  int _y;
public:
  Point(int x = 0, int y = 0) : _x(x), _y(y)
  {
  }
  void set_x(const int& value) const { _x = x; }
  int get_x() { return _x; }
  
  ...

};

Теперь код исправно работает)

ИТАК ЗАПОМНИМ!!!
Все методы класса, которые не изменяют состояние объекта следует делать константными. Это
необходимо для возможности полноценной работы с экземплярами классов посредством
константных объектов и константных ссылок.

# Раздельное объявление и определение классов (.cpp) и (.h) файлы
о сих пор мы рассматривали совместное объявление и определение классов, однако в языке C++
можно разделять объявление и определение функций в том числе по отношению к методам
класса. В этом случае в объявлении класса указываются только прототипы методов, а
определение следует далее, вне тела класса с использованием следующего синтаксиса:
```C++
<тип значения> <имя_класса>::<имя метода>([<список параметров>])
{<тело функции>}
```
Например:
```C++

// объявление класса
class Point
{
private:
  double x, y;
public:
  Point(double x = 0.0, double y = 0.0);
  void SetX(double value);
  void SetY(double value);
  double GetX() const;
  double GetY() const;
};

// определение класса
Point::Point(double x, double y): x(x), y(y) { }
void Point::SetX(double value) {x = value;}
void Point::SetY(double value) {y = value;}
double Point::GetX() const {return x;}
double Point::GetY() const {return y;
```
Более того реализацию класса можно разнести на два файла. В этом случае определение класса
помещается в заголовочный (.h) файл с тем же именем, что и имя класса, а определение в файл
реализации (.cpp) с тем же именем, что и имя класса.

Например:
Текст файла реализации Point.cpp (определение класса Point):
```C++
#include "Point.h"
// определение класса
Point::Point(double x, double y): x(x), y(y) { }
void Point::SetX(double value) {x = value;}
void Point::SetY(double value) {y = value;}
double Point::GetX() const {return x;}
double Point::GetY() const {return y;}
```
Текст файла реализации Point.h (заголовочный файл):
```C++
class Point
{
private:
  double x, y;
public:
  Point(double x = 0.0, double y = 0.0);
  void SetX(double value);
  void SetY(double value);
  double GetX() const;
  double GetY() const;
};
```

# Статические поля и методы класса
Статические переменные ( поля ) и методы относят в целом ко всему классу. Для их определения используется ключевое слово static. Например, в банке может быть множество различных вкладов, однако все вклады будут иметь какие-то общие процентные ставки. Так, для описания банковского счета определим и используем следующий класс:
```C++
#include <iostream>
 
class Account 
{
public:
    Account(double sum)
    {
        this->sum = sum;
    }
    static int getRate()
    {
        return rate;
    }
    static void setRate(int r)
    {
        rate = r;
    }
    double getIncome()
    {
        return sum + sum * rate / 100;
    }
private:
    double sum;
    static int rate;
};
int Account::rate = 8;
int main()
{
    Account account1(20000);
    Account account2(50000);
    Account::setRate(5);        // переустанавливаем значение rate
    std::cout << "Rate: " << Account::getRate() << std::endl;
    std::cout << "Rate: " << account1.getRate() << " Income: " << account1.getIncome() << std::endl;
    std::cout << "Rate: " << account2.getRate() << " Income: " << account2.getIncome() << std::endl;
    return 0;
}
```

В классе Account определена одна статическая переменная rate и две статических функции для управления этой переменной. При определении статических функций стоит учитывать, что внутри них мы можем использовать только статические переменные класса, как например, переменную rate. Нестатические переменные использовать в статических функциях нельзя.

Кроме того, в статических функциях нельзя использовать указатель this, что в принципе и так очевидно, так как this указывает на текущий объект, а статические функции относятся вцелом ко всему классу.

Также важно, что если класс содержит статические переменные, то они должны быть дополнительно определены вне класса:
```C++
int Account::rate = 8;
```
Присваивать начальное значение переменной необязательно.

Также стоит отметить, что так как статические члены относятся в целом ко всему классу, то для обращения к статическим членам используется имя класса, после которого идет оператор ::. Либо мы можем также обращаться к публичным членам класса через переменные данного класса:

```C++
Account::getRate()
account1.getRate()
```
Также нередко в классах используют статические константы:
```C++
const static int rate = 8;
```

# Дружественные функции ( friend )
Дружественные функции - это функции, которые не являются членами класса, однако имеют доступ к его закрытым членам - переменным и функциям, которые имеют спецификатор private.

Для определения дружественных функций используется ключевое слово friend. Например, определим следующую программу:
```C++
#include <iostream>
#include <string>  
 
class Auto
{
    friend void drive(Auto &);
    friend void setPrice(Auto &, int price);
public:
    Auto(std::string autoName, int autoPrice) 
    { 
        name = autoName; 
        price = autoPrice;
    }
    std::string getName(){ return name; }
    int getPrice() { return price; }
 
private:
    std::string name;   // название автомобиля
    int price;  // цена автомобиля
};
 
void drive(Auto &a) 
{ 
    std::cout << a.name << " is driven" << std::endl;
}
void setPrice(Auto &a, int price)
{
    if (price > 0) 
        a.price = price;
}
 
int main()
{
    Auto tesla("Tesla", 5000);
    drive(tesla);
    std::cout << tesla.getName() << " : " << tesla.getPrice() << std::endl;
    setPrice(tesla, 8000);
    std::cout << tesla.getName() << " : " << tesla.getPrice() << std::endl;
 
    return 0;
}
```
Здесь определен класс Auto, который представляет автомобиль. У этого класса определены приватные закрытые переменные name (название автомобиля) и price (цена автомобиля). Также в классе объявлены две дружественные функции: drive (функция вождения автомобиля) и setPrice (функция назначения цены). Обе этих функции принимают в качестве параметра ссылку на объект Auto.

Когда мы объявляем дружественные функции, то фактически мы говорим компилятору, что это друзья класса и они имеют доступ ко всем членам этого класса, в том числе закрытым.

При этом для дружественных функций не важно, определяются они под спецификатором public или private. Для них это не имеет значения.

Определение этих функций производится вне класса. И поскольку эти функции являются дружественными, то внутри этих функций мы можем через переданную ссылку Auto обратиться ко всем его закрытым переменным.

Консольный вывод программы:
![изображение](https://user-images.githubusercontent.com/86359412/201677901-28a23829-560e-4282-9f54-0165ec7d4b44.png)

Определение дружественных функций в классе

```C++
class Auto
{
    friend void Person::drive(Auto &);
    friend void Person::setPrice(Auto &, int price);
public:
    Auto(std::string autoName, int autoPrice)
    {
     ....
     
// вне класса

void Person::drive(Auto &a) {
    std::cout << name << " drives " << a.name << std::endl;
}
void Person::setPrice(Auto &a, int price) {
    if (price > 0)
        a.price = price;
}
```
