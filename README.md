# C

# lessons 8
# Перегрузка операций в С++
Различают три основных вида операторов: унарные, бинарные и n-арные (n>2).

**Унарные операторы** – это операторы, которые для вычислений требуют одного операнда, который может размещаться справа или слева от самого оператора.
```C++
i++
--a
-8
```
**Бинарные операторы** – это операторы, которые для вычисления требуют двух операндов.
```C++
a+b
f1-f2
c%d
x1*x2
```

**n-арные операторы** для вычислений требуют более двух операндов. В языке C++ есть тернарная операция ?:, которая для своей работы требует три операнда. 

Перегрузка оператора означает использование оператора для оперирования объектами классов. Перегрузка оператора – способ объявления и реализации оператора таким образом, что он обрабатывает объекты конкретных классов или выполняет некоторые другие действия. При перегрузке оператора в классе вызывается соответствующая операторная функция (operator function), которая выполняет действия, которые касаются данного класса.
Если оператор «перегружен», то его можно использовать в других методах в обычном для него виде. Например, команды поэлементного суммирования двух массивов a1 и a2:
```C++
// обычно
a1.add(a2);
a3 = add(a1, a2);

// перегрузка оператора +
a1 = a1 + a2;
a3 = a1 + a2;
```
В данном примере оператор ‘+’ считается перегруженным.

Часто задаваемый вопрос: Какими способами можно реализовать операторную функцию для заданного класса? Какие существуют разновидности операторных функций?
Для заданного класса операторную функцию в классе можно реализовать:

    1. внутри класса. В этом случае, операторная функция есть методом класса;
    2. за пределами класса. В этом случае операторная функция объявляется за пределами класса как «дружественная» (с ключевым словом friend). Более подробно о       реализации «дружественных» функций за пределами класса описывается здесь.

Общая форма операторной функции, реализованной в классе, имеет следующий вид:
```C++
return_type ClassName::operator#(arguments_list)
{
    // некоторые операции
    // ...
}
```
где

    1. return_type – тип значения, которое возвращается операторной функцией;
    2. ClassName – имя класса, в котором реализована операторная функция;
    3. operator# – ключевое слово, определяющее операторную функцию в классе. Символ # заменяется оператором языка C++, который перегружается. Например, если перегружается оператор +, то нужно указать operator+;
    4. argument_list – список параметров, которые получает операторная функция. Если перегружается бинарный оператор, то argument_list содержит один аргумент. Если перегружается унарный оператор, то список аргументов пустой.
   
Пример перегрузки унарных и бинарных операторов для класса, который содержит одиночные данные. Операторная функция реализована внутри класса.
Объявляется класс Point, реализующий точку на координатной плоскости. В классе реализованы:

    1. две внутренние переменные x, y, которые есть координатами точки;
    2. два конструктора класса;
    3. методы доступа к внутренним переменным класса GetX(), GetY(), SetX(), SetY();
    4. две операторные функции operator+() и operator-().
```C++
// Класс, который реализует точку на координатной плоскости
// класс содержит две операторные функции
class Point
{
private:
    int x, y; // координаты точки

public:
    // конструкторы класса
    Point()
    {
        x = y = 0;
    }

    Point(int nx, int ny)
    {
        x = nx;
        y = ny;
    }

    // методы доступа к членам класса
    int GetX(void) { return x; }
    int GetY(void) { return y; }
    void SetX(int nx) { x = nx; }
    void Set(int ny) { y = ny; }

    // перегруженный бинарный оператор '+'
    Point operator+(Point pt)
    {
        // p - временный объект, который создается с помощью конструктора без параметров
        Point p;
        p.x = x + pt.x;
        p.y = y + pt.y;
        return p;
    }

    // перегруженный унарный оператор '-'
    Point operator-(void)
    {
        Point p;
        p.x = -x;
        p.y = -y;
        return p;
    }
};
```

Как видно из вышеприведенного кода, операторная функция operator+() получает один параметр. Это значит, что эта функция реализует бинарный оператор ‘+’. Этот параметр соответствует операнду, который размещается в правой части бинарного оператора ‘+’. Операнд, который размещается в левой части оператора ‘+’ передается операторной функции неявно с помощью указателя this данного класса.


ВНИМАНИЕ ЭТО ОЧЕНЬ ВАЖНО!!! Нельзя перегружать следующие операторы:

    :: – расширение области видимости;
    . (точка) – доступ к члену структуры или класса;
    * – доступ по указателю;
    ?: – тернарная операция.

# Перергрузка операторов new и delete
Операторы new и delete могут быть перегружены двумя способами. Эти способы отличаются объявлением операторной функции:

    1. перегрузка операторов new и delete с помощью операторной функции, которая реализована в пределах класса. Это есть способ перегрузки new и delete для          конкретного класса. При вызове new и delete для этого класса будут вызваны перегруженные операторные функции, которые выделяют/освобождают память            специфическим образом. При вызове операторов new и delete для других классов используются глобальные операторы new и delete;
    2. глобальная перегрузка операторов new и delete. В этом случае операторы new и delete перегружаются для встроенных типов (float, int и т.д.).

Общая форма перегрузки оператора new имеет следующий вид:
```C++
return_type * operator new(size_t size)
{
    // Выделение памяти
    // ...
}
```
, где

    return_type – тип (класс), на который операторная функция возвращает указатель для которого выделена память по особому (нестандартным способом);
    size – размер памяти, которая выделяется для типа return_type. Количество байт выделяемой памяти не обязательно должно совпадать со значением size, так как в теле операторной функции память можно выделять по особому.

Общая форма перегрузки оператора delete имеет следующий вид:
```C++
void operator delete(void * pointer)
{
    // освобождение памяти, на которую указывает указатель pointer
    // ...
}
```
здесь pointer – указатель на область памяти, которая была предварительно выделена оператором new.
Если в программе перегружаются операторы new и delete, то возникают два вида этих операторов:

    1. перегруженные операторы new и delete. Эти перегруженные операторы применяются для конкретного класса (классов), в котором есть операторные функции operator new() и operator delete();
    2. глобальные операторы new и delete (не перегруженные). Эти операторы применяются для классов, которые не содержат операторных функций перегружающих операторы new и delete.

Для каждого класса компилятор определяет: какой вариант операторов new и delete нужно выбрать: глобальный или для конкретного класса.


# Понятие шаблона класса. Ключевое слово template. Преимущества использования шаблонов. Примеры объявления и использования шаблонов классов. Аргументы в шаблонах.

Часто, при разработке классов для разных типов данных, программисту приходится писать программный код для каждого типа в отдельности. Методы и операции над данными разных типов могут содержать один и тот же повторяемый код. Во избежание повторяемости написания кода для разных типов данных, в языке C++ используются так называемые шаблоны (templates).

Шаблон класса позволяет оперировать данными разных типов в общем. То есть, нет привязки к некоторому конкретному типу данных (int, float, …). Вся работа выполняется над некоторым обобщенным типом данных, например типом с именем T.

Фактически, объявление шаблона класса есть только описанием. Создание реального класса с заданным типом данных осуществляется компилятором в момент компиляции, когда объявляется объект класса.

В простейшем случае общая форма объявления шаблона класса без аргументов имеет следующий вид:
```C++
template <class T> class ClassName
{
    // тело класса
    // ...
}
```
где

    1. T – обобщенное имя типа, который используется методами класса;
    2. ClassName – имя класса, который содержит методы оперирования обобщенным типом класса.

Общая форма объявления объекта шаблонного класса имеет следующий вид:

```C++
ClassName <type> objName;
```
где

    1. ClassName – имя шаблонного класса;
    2. type – конкретный тип данных в программе;
    3. objName – имя объекта (экземпляра) класса.

Ключевое слово class может быть заменено на слово typename. В этом случае общая форма объявления шаблонного класса может быть следующей:
```C++
template <typename T>
class ClassName 
{
    // тело класса 
    // ... 
}
```
В данном случае нет разницы между использованием слов class и typename.

Объявление шаблона класса дает следующие преимущества:

    1. избежание повторяемости написания программного кода для разных типов данных. Программный код (методы, функции) пишется для некоторого обобщенного типа T. Название обобщенного типа можно давать любое, например TTT;
    2. уменьшение текстовой части программного кода, и, как следствие, повышение читабельности программ;
    3. обеспечение удобного механизма передачи аргументов в шаблон класса с целью их обработки методами класса.

Пример:
```C++
// шаблон класса, реализующего число разных типов
template <class T>
class MyNumber
{
    public:
    // конструктор
    MyNumber(void) { }

    // метод, умножающий число на 2
    void Mult2(T* t);

    // метод, возвращающий квадрат числа для некоторого типа T
    T MySquare(T);

    // метод, который делит два числа типа T и возвращает результат типа T
    T DivNumbers(T, T);
};

// реализация метода, умножающего число на 2
template <class T> void MyNumber<T>::Mult2(T* t)
{
    *t = (*t)*2;
}

// реализация метода, возвращающего квадрат числа
template <class T> T MyNumber<T>::MySquare(T number)
{
    return (T)(number*number);
}

// метод, который делит 2 числа и возвращает результат от деления
template <class T> T MyNumber<T>::DivNumbers(T t1, T t2)
{
    return (T)(t1/t2);
}
```
второй файл:
```C++
MyNumber <int> mi; // объект mi класса работает с типом int
MyNumber <float> mf; // объект mf работает с типом float

int d = 8;
float x = 9.3f;

// умножение числа на 2
mi.Mult2(&d); // d = 16
mf.Mult2(&x); // x = 18.6

// возведение числа в квадрат
int dd;
dd = mi.MySquare(9); // dd = 81 - целое число

double z;
z = mf.MySquare(1.1); // z = 1.21000... - вещественное число

// деление чисел
long int t;
float f;

t = mi.DivNumbers(5, 2); // t = 2 - деление целых чисел
f = mf.DivNumbers(5, 2); // f = 2.5 - деление вещественных чисел
```
