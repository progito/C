# C

# lessons 7
# Наследование
Наследование – концепция ООП, позволяющая одним объектам приобретать атрибуты и поведение других объектов. Наследование помогает сделать разработку более экономной и обозримой, так как объекты пользуются одними и теми же атрибутами, а также формами поведения без дублирования реализующих их программных кодов. При наследовании класс - наследник может как расширять функциональность класса-предка, так и неким образом модифицировать или уточнять её. 

В языке C++ поддерживается концепция множественного наследования, это значит, что в общем
случае у одного класса может быть несколько классов предков. В литературе можно встретить различные
определения для базового класса: предок, родительский класс или суперкласс. Производный
класс называют потомком, дочерним классом или подклассом.

При наследовании родительские и дочерние классы образуют так называемую иерархию
наследования, при этом количество уровней в этой иерархии в общем случае не ограничено.
![изображение](https://user-images.githubusercontent.com/86359412/201679162-fd532918-ffa0-4854-9eb0-8ef3c8921518.png)

При наследовании выполняются следующие правила:

    1. Информационные поля и методы класса-предка наследуются всеми его классами-
       наследниками независимо от числа промежуточных уровней иерархии.
    2. Доступ к полям и методам классов-предков для любого класса-наследника выполняется
       так, как будто бы они описаны в самом дочернем типе, если доступ к этим членам класса
       не ограничен спецификаторами доступа.
    3. Класс-наследник может доопределить произвольное число собственных методов и полей.
    4. Если идентификаторы полей или методов в классах-наследниках совпадают с таковыми в
       классах-предках, то в этом случае говорят, что дочерний член класса перекрывает
       одноименный родительский член класса. 
Синтаксис для одиночного наследования:
```C++
class <имя класса>:[<атрибут наследования>]<имя базового класса> {...}
```
Пример:
```C++
class A{
 ...
};
class B : public A{
  ...
};
```

# Виртуальные методы и абстрактные классы
Виртуальные методы объявляются с использованием спецификатора virtual, при этом если в
базовом классе метод объявлен как виртуальный, то в производном классе функция
автоматически становится виртуальной.
```C++
virtual <тип возвращаемого значения> <имя метода>([<список параметров>])
{...};
```
Виртуальные методы объявляются в базовых классах и, как правило переопределяются в классах-
потомках. Механизм виртуальных функций является средством реализации концепции
полиморфизма и позволяет однообразно работать с объектами различных типов.

```C++
class A
{
public:
    void f() { printf("A::f()\n"); };
    virtual void vf() { printf("A::vf()\n"); };
};
class B : public A
{
public:
    void f() { printf("B::f()\n"); };
    void vf() { printf("B::vf()\n"); };
};
int main()
{
    A a;
    B b;
    A* pa = &a;
    B* pb = &b;
    A* pbase = pb;
    pa->f(); //A::f()
    pb->f(); //B::f()
    pbase->f(); //A::f()
    pa->vf(); //A::vf()
    pb->vf(); //B::vf()
    pbase->vf(); //B::vf()
    getchar();
}
```
Такое поведение обусловлено тем, что при обращении к виртуальному методу выбор
вызываемого метода зависит не от типа указателя, а от фактического типа объекта, на который
этот указатель установлен. Поэтому в последнем случае вызывается метод класса-потомка,
несмотря на то, что указатель имеет формальный тип указателя на объект класса предка.

Часто в базовом классе определяют лишь интерфейс объекта, но не подразумевают его
реализацию. При этом предполагается, что такие методы будут переопределены в классах
потомках. В C++ в таком случае используют чисто виртуальные методы. Синтаксически они
определяются указанием «=0» после списка параметров:
```C++
virtual <тип возвращаемого значения> <имя метода>([<список параметров>]) = 0;
```

```C++
class Shape{
public:
  virtual ~Shape() {};
  virtual void Shift(int dx, int dy) = 0;
  virtual void Rotate(double angle) = 0;
  virtual void Print() = 0;
};
```
Если класс содержит хотя бы одну чисто виртуальную функцию такой
класс называют **абстрактным**. 
При разработке программ часто применяют классы, содержащие только чисто виртуальные
функции, такие классы называют интерфейсными. Эти классы используют для определения
протокола взаимодействия между объектами, что позволяет устранить зависимости от
конкретных реализаций тех или иных классов и упрощает как разработку, так и последующее
сопровождение программы.

# Обработка исключений try-catch
Исключения могут быть выброшены в любом месте кода. Для этого в блоке нужно прописать throw. 
```C++
throw "error";
```
В блоке try происхожит поиск throw ( если нашел то переходит в catch )
```C++
try {
   // protected code
} catch(...) {
  // code to handle any exception
}
```
Таким образом, строки кода с catch и throw выполняются только тогда, когда try обнаруживает исключение в коде. Если все данные удовлетворяют условиям кода, то блок с исключениями просто пропускается программой.
```C++
#include <iostream>
using namespace std;
 
class Test {
public:
    Test() { cout << "Constructor of Test " << endl; }
    ~Test() { cout << "Destructor of Test " << endl; }
};
 
int main() {
    try {
        Test t1;
        throw 10;
    }
    catch (int i) {
        cout << "Caught " << i << endl;
    }
}
```
