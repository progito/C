# C

# lessons 4
# Немного полезного из STD
fill_n() - присваивает count элементам из диапазона [first,first+count) значение value.
```C++
std::fill_n(vector, count, value)
```

# Enum ( перечесления )
Перечисления (enum) представляют еще один способ определения своих типов. Их отличительной особенностью является то, что они содержат набор числовых констант.

Определим простейшее перечисление:
```C++
enum seasons {
    spring,
    summer,
    autumn,
    winter
};
```
Для определения перечисления применяется ключевое слово enum, после которого идет название перечисления. Затем в фигурных скобках идет перечисление констант через запятую. Каждой константе по умолчанию будет присваиваться числовое значение начиная с нуля. 
```C++
enum seasons {
    spring = 1,
    summer, //2
    autumn, //3
    winter  //4
};
```
Также можно задать значение для каждой константы:
```C++
enum seasons {
    spring = 1,
    summer = 2,
    autumn = 4,
    winter = 8
};
```
Когда необходимы перечисления? Перечисления могут использоваться, когда у нас есть ряд логически связанных констант, которые естественно лучше определить в одном общем типе данных. Например:
```C++
#include <iostream>
enum operations {
    add = 1,
    subtract = 2,
    multiply = 4
};
int main() {
    int operation;
    int x1;
    int x2;
    int result;
 
    std::cout << "Add: 1 \tSubtract: 2 \tMultiply: 4" << std::endl;
    std::cout << "Input x1: ";
    std::cin >> x1;
    std::cout << "Input x2: ";
    std::cin >> x2;
    std::cout << "Input operation number: ";
    std::cin >> operation;
 
    switch (operation)
    {
    case operations::add: 
        result = x1 + x2;
        break;
    case operations::subtract:
        result = x1 - x2;
        break;
    case operations::multiply:
        result = x1 * x2;
        break;
    }
 
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```
# Структура C++ ( struct )
Структура в языке C++ представляет собой производный тип данных, который представляет какую-то определенную сущность, также как и класс. Нередко структуры применителько к С++ также называют классами. И в реальности различия между ними не такие большие.

Для определения структуры применяется ключевое слово struct, а сам формат определения выглядит следующим образом:
```C++
#include <iostream>
#include <string>
 
struct person {
    int age;
    std::string name;
};
 
int main() {
    person tom;
    tom.name = "Tom";
    tom.age = 34;
    std::cout << "Name: " << tom.name << "\tAge: " << tom.age << std::endl;
    return 0;
}
```
По сути структура похожа на класс, то есть с помощью структур также можно определять сущности для использования в программе. В то же время все члены структуры, для которых не используется спецификатор доступа (public, private), по умолчанию являются открытыми (public). Тогда как в классе все его члены, для которых не указан спецификатор доступа, являются закрытыми (private).

Кроме того мы можем инициализировать структуру, присвоив ее переменным значения с помощью синтаксиса инициализации:
```C++
person tom = { 34, "Tom" };
```

# Объединения

На структуры во многом похожи объединения. Объединения также хранят набор элементов, но в отличие от структуры все элементы объединения имеют нулевое смещение. А это значит, что разные элементы занимают в памяти один и тот же участок.

Для определения объединений применяется ключевое слово union и следующий формальный синтаксис:
```C++
union имя_объединения {
    определения_элементов
};
```
Пример:
```C++
union code {
    int digit;
    char letter;
};
```
После определения объединения мы можем создать его переменную и присвоить ей какое-либо значение:
```C++
union code id;
```
```C++
union code id = {120}; // инициализация первого элемента ( digit )
// или
union code id;
id.digit = 120;
```
# Работа с файлами
Для работы с файлами в C++ нужно прописать #include <fstream>

Базовый код ( записи данных в файл ):
```C++
#include "stdafx.h"
#include <fstream>
#include <iostream>
using namespace std;
 
int main()
{
    ofstream fout("file.txt"); // создаём объект класса ofstream для записи и связываем его с файлом file.txt
    fout << "Работа с файлами в С++"; // запись строки в файл
    fout.close(); // закрываем файл
    system("pause");
    return 0;
}
```

Базовый код ( чтения данных из файла ):
```C++
#include "stdafx.h"
#include <fstream>
#include <iostream>
using namespace std;
 
int main() {
    setlocale(LC_ALL, "rus"); // корректное отображение Кириллицы
    char buff[50]; // буфер промежуточного хранения считываемого из файла текста
    ifstream fin("cppstudio.txt"); // открыли файл для чтения
 
    fin >> buff; // считали первое слово из файла
    cout << buff << endl; // напечатали это слово
 
    fin.getline(buff, 50); // считали строку из файла
    fin.close(); // закрываем файл
    cout << buff << endl; // напечатали эту строку
 
    system("pause");
    return 0;
}
```
режимы открытия файлов:
  1. ios_base::in - открыть файл для чтения
  2. ios_base::out - открыть файл для записи
  3. ios_base::ate - при открытии переместить указатель в конец файла
  4. ios_base::app - открыть файл для записи в конец файла
  5. ios_base::trunc - удалить содержимое файла, если он существует
  6. ios_base::binary - открытие файла в двоичном режиме
Например:
```C++
ofstream fout("file.txt", ios_base::app); // открываем файл для добавления информации к концу файла
fout.open("file.txt", ios_base::app); // открываем файл для добавления информации к концу файла
```
Также можно сделать проверку на открытие файла:
```C++
if (!fout.is_open()) // если файл небыл открыт
{
     cout << "Файл не может быть открыт или создан\n"; // напечатать соответствующее сообщение
     return 1; // выполнить выход из программы
}
```

# Рекурсия
Рекурсия – это такой способ определения функции, при котором результат возврата из функции для данного значения аргумента определяется на основе результата возврата из той же функции для предыдущего (меньшего или большего) значения аргумента. Простыми словами рекурсия - это способ оперд-я функции при котором эта функция сама себя вызывает.

Рекурсия нужна чтобы ускорять работу программы ( т.к рекурсия заменяет циклы ).
Пример рекурсии:
```C++
#include <iostream>
 
int factorial(int n){
    if(n>1)
        return n * factorial(n-1);
    return 1;
}

int main() {
    int n = 5;
    int result = factorial(n);
    std::cout << "Factorial of " << n << " is equal to " << result << std::endl;
    return 0;
}
```

# Перегрузка функций в C++
Перегрузка функций в C++ используется, когда нужно сделать одно и то же действие с разными типами данных. Для примера, создадим простую функцию max, которая будет определять максимальное из двух целых чисел. 
```C++
int max(int num1, int num2) {
    if (num1 > num2)
        return num1;
    return num2;
}
```
Для того, чтобы сделать аналог этой функции для чисел с плавающей запятой, выполним перегрузку этой функции:
```C++
double max(double num1, double num2) {
    if (num1 > num2)
        return num1;
    return num2;
}
```
Теперь, когда мы будет вызывать функцию max с целыми параметрами, то вызовется первая функция. 
А если с дробными — то вторая. Например:
```C++
int imax = max(1, 10); // Здесь будет использоваться первый вариант функции max
double dmax = max(1.0, 20.0); // А здесь - второй
```
